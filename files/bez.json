{"blocks":[{"type":"group","output":"M[\"p1\"] = { x: 276, y: 121, recorded: [{\"x\":184,\"y\":85},{\"x\":189,\"y\":69},{\"x\":194,\"y\":69},{\"x\":205,\"y\":71},{\"x\":218,\"y\":77},{\"x\":236,\"y\":75},{\"x\":247,\"y\":72},{\"x\":251,\"y\":71},{\"x\":256,\"y\":71},{\"x\":267,\"y\":79},{\"x\":274,\"y\":90},{\"x\":274,\"y\":90},{\"x\":278,\"y\":109},{\"x\":278,\"y\":112},{\"x\":278,\"y\":122},{\"x\":278,\"y\":122},{\"x\":278,\"y\":122},{\"x\":278,\"y\":122},{\"x\":277,\"y\":122},{\"x\":277,\"y\":121},{\"x\":276,\"y\":121}] }\nM[\"p2\"] = { x: 44, y: 244, recorded: [{\"x\":246,\"y\":265},{\"x\":339,\"y\":488},{\"x\":339,\"y\":471},{\"x\":334,\"y\":455},{\"x\":329,\"y\":441},{\"x\":322,\"y\":422},{\"x\":319,\"y\":417},{\"x\":314,\"y\":405},{\"x\":301,\"y\":386},{\"x\":296,\"y\":379},{\"x\":292,\"y\":374},{\"x\":287,\"y\":369},{\"x\":282,\"y\":363},{\"x\":282,\"y\":363},{\"x\":279,\"y\":361},{\"x\":279,\"y\":361},{\"x\":279,\"y\":361},{\"x\":278,\"y\":360},{\"x\":277,\"y\":357},{\"x\":276,\"y\":356},{\"x\":269,\"y\":333},{\"x\":265,\"y\":318},{\"x\":263,\"y\":308},{\"x\":252,\"y\":275},{\"x\":247,\"y\":265},{\"x\":242,\"y\":257},{\"x\":238,\"y\":251},{\"x\":239,\"y\":251},{\"x\":241,\"y\":251},{\"x\":256,\"y\":254},{\"x\":250,\"y\":254},{\"x\":189,\"y\":254},{\"x\":159,\"y\":253},{\"x\":132,\"y\":247},{\"x\":104,\"y\":240},{\"x\":94,\"y\":236},{\"x\":87,\"y\":232},{\"x\":82,\"y\":229},{\"x\":73,\"y\":223},{\"x\":71,\"y\":221},{\"x\":64,\"y\":216},{\"x\":57,\"y\":211},{\"x\":55,\"y\":210},{\"x\":49,\"y\":208},{\"x\":43,\"y\":205},{\"x\":39,\"y\":204},{\"x\":34,\"y\":203},{\"x\":33,\"y\":203},{\"x\":32,\"y\":203},{\"x\":42,\"y\":219},{\"x\":44,\"y\":230},{\"x\":44,\"y\":232},{\"x\":42,\"y\":238},{\"x\":42,\"y\":242},{\"x\":41,\"y\":249},{\"x\":41,\"y\":259},{\"x\":48,\"y\":258},{\"x\":48,\"y\":257},{\"x\":47,\"y\":254},{\"x\":46,\"y\":252},{\"x\":45,\"y\":249},{\"x\":45,\"y\":246},{\"x\":44,\"y\":244}] }\nM[\"p3\"] = { x: 341, y: 411, recorded: [{\"x\":341,\"y\":411}] }\nlet sketch = (p) => {\n\n  // let sound = p5sound\n\n  let x, y\n  let title = \"CREATIVE CODING CLUB\"\n  let sub_title = \"Livecoding Music\"\n  let sub_sub_title = \"(workshop/jam-session)\"\n  let room = \"[ROOM 415]\"\n  let time = \"28 Jan, 4pm\"\n  let font\n  let collect = []\n  let t = 0\n  \n\n  let half_w = () => p.width / 2\n  let half_h = () => p.height / 2\n  let mul_vec = (vec, mul)  => ({x: vec.x*mul, y:vec.y*mul})\n  let add_vec = (vec, vec2) => ({x: vec.x+vec2.x, y:vec.y*vec2.y})\n  let maybe_offset = (scale, prob, off = 0) => \n        Math.random() > prob\n        ? p.noise(p.frameCount + off) * scale - scale/2\n        : 0\n\n  p.preload = () =>{\n    font = p.loadFont(\"/fonts/hermit.otf\")\n  }\n  \n  p.setup = () => {\n    p.createCanvas(1500, 2500)\n    p.textFont(font)\n  }\n\n  p.draw = () => {\n    p.background(0, 0,255)\n    p.textSize(100)\n\n    p.fill(255, 255, 0)\n\n    let xx =  maybe_offset(400, .98)\n    let yy =  maybe_offset(1400, .98)\n    \n    \n\n    // if(p.random() > .95) {\n    //   if(p.random() > .5) p.blendMode(p.MULTIPLY)\n    //   else p.blendMode(p.BLEND)\n    // }\n\n    let h = p.textWidth(title)/2\n\n    let vecs = [mul_vec(M.p1, 5),mul_vec(M.p2, 5), mul_vec(M.p3, 5)]\n\n    // vecs = vecs.map((v) => add_vec(\n    //   v, {x: maybe_offset(300, .98),\n    //        y: maybe_offset(300, .98)\n    //      }\n    // ))\n\n    p.strokeWeight(1)\n    grid(p.floor(t*100), p.floor(t*50))\n    curve(...vecs)\n\n\n    p.fill(255)\n    p.stroke(255, 0, 255)\n    p.strokeWeight(30)\n    text_glitch(title, half_w() - h, half_h()/2)\n    p.strokeWeight(0)\n    \n    p.textSize(70)\n    p.fill(255, 255, 0)\n    let t_w = p.textWidth(sub_sub_title)\n    p.rect(240, half_h() + 200 ,\n           240+t_w, 150, 90 )\n    \n    p.fill( 255, 255, 0)\n    p.rect(half_w() - xx , half_h() + yy + 300, 800, 200, 250)\n    \n    p.fill(0, 0, 255)\n    p.text(sub_sub_title,  240, half_h() + 300 )\n\n    p.textSize(100)\n    p.text(time, half_w(), half_h() + 450 )\n\n    p.textSize(100)\n    \n    p.fill(255,0, 255)\n    p.rect(half_w(), half_h(),\n           240+t_w, 250, 90 )\n    p.fill(255, 255, 0)\n    p.text(room, half_w(), half_h()) \n    \n    \n    p.textSize(150)\n    animated_text(sub_title, 50, half_h() + 200)\n    \n    \n    \n    \n\n\n    t+=.002\n    if (t > 1) {\n      collect = []\n      t = 0\n    }\n\n    // if (p.random() > .99) p.noLoop()\n    \n  }\n\n\n  function grid(rows, cols) {\n    p.stroke(255, 127)\n    let y_scale = p.height / rows\n    let x_scale = p.width / cols\n    \n    for(let y = 0; y < rows; y++){\n      p.line(0, y*y_scale, p.width, y*y_scale)\n    }\n    \n    for(let x = 0; x < cols; x++){\n      p.line(x*x_scale, 0, x*x_scale, p.height)\n    }\n  }\n\n  function animated_text(text, x, y){\n    let letters = text.split(\"\")\n    let last_x=x, last_y=y\n    let scale = 300\n    let off = 0\n    \n    letters.forEach((letter, i)=>{\n      let offset_y = maybe_offset(scale, .98, off) - (y*t)/(i+1)\n      let t_w = p.textWidth(letter)\n      p.strokeWeight(1)\n      // let c1 = p.color(255, 0, 255)\n      // let c2 = p.color(0, 0, 255)\n      \n      let c1 = p.color(255)\n      let c2 = p.color(255, 255, 0)\n      let cc = p.lerpColor(c1, c2, i/letters.length)\n      p.stroke(cc)\n      p.noFill()\n      // p.strok\n      p.ellipse(last_x, last_y + offset_y, t_w*i ,t_w*i)\n      p.fill(0, 255, 55)\n      \n      p.stroke(0,0,255)\n      p.strokeWeight(5)\n      p.text(letter, last_x, last_y + offset_y)\n      off++\n      last_x += t_w\n    }) \n    \n  }\n\n  function text_glitch(text, x, y){\n    let letters = text.split(\"\")\n    let last_x=x, last_y=y\n    let off = 0\n\n    let scale = 300\n    \n    letters.forEach((letter)=>{\n      let offset_y = maybe_offset(scale, .98, off)\n      p.text(letter, last_x, last_y + offset_y)\n      off++\n      last_x += p.textWidth(letter)\n    }) \n  }\n\n  function curve(p1, p2,  p3,) {\n    p.strokeWeight(3)\n    p.stroke(255, 255, 0)\n    p.fill(0, 55)\n    let b1 = line(p1, p2)\n    let b2 = line(p2, p3)\n    let point = line(b1, b2)\n    \n    collect.push(point)\n    collect.forEach((pp) => {\n      p.fill(0)\n      p.circle(pp.x, pp.y, 5)\n    })\n\n  }\n\n  function line(point1, point2) {\n    let x1 = point1.x\n    let y1 = point1.y\n    let x2 = point2.x\n    let y2 = point2.y\n\n    let lerp_x = p.lerp(x1, x2, t)\n    let lerp_y = p.lerp(y1, y2, t)\n\n    p.line(x1, y1, x2, y2)\n    p.circle(x1, y1, 10)\n    p.circle(x2, y2, 10)\n    \n    p.circle(lerp_x, lerp_y, 2)\n\n    return({x: lerp_x, y: lerp_y})\n    \n  }\n\n  \n\n}\n\n\n\nnew p5(sketch)\n\n\nsetTimeout(() => {\n  document.querySelector(\"canvas\").style.transform = `\n  translateX(-25%)\n  translateY(-32%)\n  scale(.35)`\n  \n  document.querySelector(\"canvas\").style.filter = ` invert()`}, 100)","blocks":[{"id":"g7mloq","type":"vect","code":"","active":false,"output":"M[\"p1\"] = { x: 276, y: 121, recorded: [{\"x\":184,\"y\":85},{\"x\":189,\"y\":69},{\"x\":194,\"y\":69},{\"x\":205,\"y\":71},{\"x\":218,\"y\":77},{\"x\":236,\"y\":75},{\"x\":247,\"y\":72},{\"x\":251,\"y\":71},{\"x\":256,\"y\":71},{\"x\":267,\"y\":79},{\"x\":274,\"y\":90},{\"x\":274,\"y\":90},{\"x\":278,\"y\":109},{\"x\":278,\"y\":112},{\"x\":278,\"y\":122},{\"x\":278,\"y\":122},{\"x\":278,\"y\":122},{\"x\":278,\"y\":122},{\"x\":277,\"y\":122},{\"x\":277,\"y\":121},{\"x\":276,\"y\":121}] }","name":"p1","size":368,"x":276,"y":121,"recorded":[{"x":184,"y":85},{"x":189,"y":69},{"x":194,"y":69},{"x":205,"y":71},{"x":218,"y":77},{"x":236,"y":75},{"x":247,"y":72},{"x":251,"y":71},{"x":256,"y":71},{"x":267,"y":79},{"x":274,"y":90},{"x":274,"y":90},{"x":278,"y":109},{"x":278,"y":112},{"x":278,"y":122},{"x":278,"y":122},{"x":278,"y":122},{"x":278,"y":122},{"x":277,"y":122},{"x":277,"y":121},{"x":276,"y":121}],"focus":false},{"id":"rulfpd","type":"vect","code":"","active":false,"output":"M[\"p2\"] = { x: 44, y: 244, recorded: [{\"x\":246,\"y\":265},{\"x\":339,\"y\":488},{\"x\":339,\"y\":471},{\"x\":334,\"y\":455},{\"x\":329,\"y\":441},{\"x\":322,\"y\":422},{\"x\":319,\"y\":417},{\"x\":314,\"y\":405},{\"x\":301,\"y\":386},{\"x\":296,\"y\":379},{\"x\":292,\"y\":374},{\"x\":287,\"y\":369},{\"x\":282,\"y\":363},{\"x\":282,\"y\":363},{\"x\":279,\"y\":361},{\"x\":279,\"y\":361},{\"x\":279,\"y\":361},{\"x\":278,\"y\":360},{\"x\":277,\"y\":357},{\"x\":276,\"y\":356},{\"x\":269,\"y\":333},{\"x\":265,\"y\":318},{\"x\":263,\"y\":308},{\"x\":252,\"y\":275},{\"x\":247,\"y\":265},{\"x\":242,\"y\":257},{\"x\":238,\"y\":251},{\"x\":239,\"y\":251},{\"x\":241,\"y\":251},{\"x\":256,\"y\":254},{\"x\":250,\"y\":254},{\"x\":189,\"y\":254},{\"x\":159,\"y\":253},{\"x\":132,\"y\":247},{\"x\":104,\"y\":240},{\"x\":94,\"y\":236},{\"x\":87,\"y\":232},{\"x\":82,\"y\":229},{\"x\":73,\"y\":223},{\"x\":71,\"y\":221},{\"x\":64,\"y\":216},{\"x\":57,\"y\":211},{\"x\":55,\"y\":210},{\"x\":49,\"y\":208},{\"x\":43,\"y\":205},{\"x\":39,\"y\":204},{\"x\":34,\"y\":203},{\"x\":33,\"y\":203},{\"x\":32,\"y\":203},{\"x\":42,\"y\":219},{\"x\":44,\"y\":230},{\"x\":44,\"y\":232},{\"x\":42,\"y\":238},{\"x\":42,\"y\":242},{\"x\":41,\"y\":249},{\"x\":41,\"y\":259},{\"x\":48,\"y\":258},{\"x\":48,\"y\":257},{\"x\":47,\"y\":254},{\"x\":46,\"y\":252},{\"x\":45,\"y\":249},{\"x\":45,\"y\":246},{\"x\":44,\"y\":244}] }","name":"p2","size":500,"x":44,"y":244,"recorded":[{"x":246,"y":265},{"x":339,"y":488},{"x":339,"y":471},{"x":334,"y":455},{"x":329,"y":441},{"x":322,"y":422},{"x":319,"y":417},{"x":314,"y":405},{"x":301,"y":386},{"x":296,"y":379},{"x":292,"y":374},{"x":287,"y":369},{"x":282,"y":363},{"x":282,"y":363},{"x":279,"y":361},{"x":279,"y":361},{"x":279,"y":361},{"x":278,"y":360},{"x":277,"y":357},{"x":276,"y":356},{"x":269,"y":333},{"x":265,"y":318},{"x":263,"y":308},{"x":252,"y":275},{"x":247,"y":265},{"x":242,"y":257},{"x":238,"y":251},{"x":239,"y":251},{"x":241,"y":251},{"x":256,"y":254},{"x":250,"y":254},{"x":189,"y":254},{"x":159,"y":253},{"x":132,"y":247},{"x":104,"y":240},{"x":94,"y":236},{"x":87,"y":232},{"x":82,"y":229},{"x":73,"y":223},{"x":71,"y":221},{"x":64,"y":216},{"x":57,"y":211},{"x":55,"y":210},{"x":49,"y":208},{"x":43,"y":205},{"x":39,"y":204},{"x":34,"y":203},{"x":33,"y":203},{"x":32,"y":203},{"x":42,"y":219},{"x":44,"y":230},{"x":44,"y":232},{"x":42,"y":238},{"x":42,"y":242},{"x":41,"y":249},{"x":41,"y":259},{"x":48,"y":258},{"x":48,"y":257},{"x":47,"y":254},{"x":46,"y":252},{"x":45,"y":249},{"x":45,"y":246},{"x":44,"y":244}]},{"id":"02mi0g","type":"vect","code":"","active":true,"output":"M[\"p3\"] = { x: 341, y: 411, recorded: [{\"x\":341,\"y\":411}] }","name":"p3","size":500,"x":341,"y":411,"recorded":[{"x":341,"y":411}]},{"id":"in2sf","type":"default","code":"","active":false,"focus":false,"focused":false,"output":"let sketch = (p) => {\n\n  // let sound = p5sound\n\n  let x, y\n  let title = \"CREATIVE CODING CLUB\"\n  let sub_title = \"Livecoding Music\"\n  let sub_sub_title = \"(workshop/jam-session)\"\n  let room = \"[ROOM 415]\"\n  let time = \"28 Jan, 4pm\"\n  let font\n  let collect = []\n  let t = 0\n  \n\n  let half_w = () => p.width / 2\n  let half_h = () => p.height / 2\n  let mul_vec = (vec, mul)  => ({x: vec.x*mul, y:vec.y*mul})\n  let add_vec = (vec, vec2) => ({x: vec.x+vec2.x, y:vec.y*vec2.y})\n  let maybe_offset = (scale, prob, off = 0) => \n        Math.random() > prob\n        ? p.noise(p.frameCount + off) * scale - scale/2\n        : 0\n\n  p.preload = () =>{\n    font = p.loadFont(\"/fonts/hermit.otf\")\n  }\n  \n  p.setup = () => {\n    p.createCanvas(1500, 2500)\n    p.textFont(font)\n  }\n\n  p.draw = () => {\n    p.background(0, 0,255)\n    p.textSize(100)\n\n    p.fill(255, 255, 0)\n\n    let xx =  maybe_offset(400, .98)\n    let yy =  maybe_offset(1400, .98)\n    \n    \n\n    // if(p.random() > .95) {\n    //   if(p.random() > .5) p.blendMode(p.MULTIPLY)\n    //   else p.blendMode(p.BLEND)\n    // }\n\n    let h = p.textWidth(title)/2\n\n    let vecs = [mul_vec(M.p1, 5),mul_vec(M.p2, 5), mul_vec(M.p3, 5)]\n\n    // vecs = vecs.map((v) => add_vec(\n    //   v, {x: maybe_offset(300, .98),\n    //        y: maybe_offset(300, .98)\n    //      }\n    // ))\n\n    p.strokeWeight(1)\n    grid(p.floor(t*100), p.floor(t*50))\n    curve(...vecs)\n\n\n    p.fill(255)\n    p.stroke(255, 0, 255)\n    p.strokeWeight(30)\n    text_glitch(title, half_w() - h, half_h()/2)\n    p.strokeWeight(0)\n    \n    p.textSize(70)\n    p.fill(255, 255, 0)\n    let t_w = p.textWidth(sub_sub_title)\n    p.rect(240, half_h() + 200 ,\n           240+t_w, 150, 90 )\n    \n    p.fill( 255, 255, 0)\n    p.rect(half_w() - xx , half_h() + yy + 300, 800, 200, 250)\n    \n    p.fill(0, 0, 255)\n    p.text(sub_sub_title,  240, half_h() + 300 )\n\n    p.textSize(100)\n    p.text(time, half_w(), half_h() + 450 )\n\n    p.textSize(100)\n    \n    p.fill(255,0, 255)\n    p.rect(half_w(), half_h(),\n           240+t_w, 250, 90 )\n    p.fill(255, 255, 0)\n    p.text(room, half_w(), half_h()) \n    \n    \n    p.textSize(150)\n    animated_text(sub_title, 50, half_h() + 200)\n    \n    \n    \n    \n\n\n    t+=.002\n    if (t > 1) {\n      collect = []\n      t = 0\n    }\n\n    // if (p.random() > .99) p.noLoop()\n    \n  }\n\n\n  function grid(rows, cols) {\n    p.stroke(255, 127)\n    let y_scale = p.height / rows\n    let x_scale = p.width / cols\n    \n    for(let y = 0; y < rows; y++){\n      p.line(0, y*y_scale, p.width, y*y_scale)\n    }\n    \n    for(let x = 0; x < cols; x++){\n      p.line(x*x_scale, 0, x*x_scale, p.height)\n    }\n  }\n\n  function animated_text(text, x, y){\n    let letters = text.split(\"\")\n    let last_x=x, last_y=y\n    let scale = 300\n    let off = 0\n    \n    letters.forEach((letter, i)=>{\n      let offset_y = maybe_offset(scale, .98, off) - (y*t)/(i+1)\n      let t_w = p.textWidth(letter)\n      p.strokeWeight(1)\n      // let c1 = p.color(255, 0, 255)\n      // let c2 = p.color(0, 0, 255)\n      \n      let c1 = p.color(255)\n      let c2 = p.color(255, 255, 0)\n      let cc = p.lerpColor(c1, c2, i/letters.length)\n      p.stroke(cc)\n      p.noFill()\n      // p.strok\n      p.ellipse(last_x, last_y + offset_y, t_w*i ,t_w*i)\n      p.fill(0, 255, 55)\n      \n      p.stroke(0,0,255)\n      p.strokeWeight(5)\n      p.text(letter, last_x, last_y + offset_y)\n      off++\n      last_x += t_w\n    }) \n    \n  }\n\n  function text_glitch(text, x, y){\n    let letters = text.split(\"\")\n    let last_x=x, last_y=y\n    let off = 0\n\n    let scale = 300\n    \n    letters.forEach((letter)=>{\n      let offset_y = maybe_offset(scale, .98, off)\n      p.text(letter, last_x, last_y + offset_y)\n      off++\n      last_x += p.textWidth(letter)\n    }) \n  }\n\n  function curve(p1, p2,  p3,) {\n    p.strokeWeight(3)\n    p.stroke(255, 255, 0)\n    p.fill(0, 55)\n    let b1 = line(p1, p2)\n    let b2 = line(p2, p3)\n    let point = line(b1, b2)\n    \n    collect.push(point)\n    collect.forEach((pp) => {\n      p.fill(0)\n      p.circle(pp.x, pp.y, 5)\n    })\n\n  }\n\n  function line(point1, point2) {\n    let x1 = point1.x\n    let y1 = point1.y\n    let x2 = point2.x\n    let y2 = point2.y\n\n    let lerp_x = p.lerp(x1, x2, t)\n    let lerp_y = p.lerp(y1, y2, t)\n\n    p.line(x1, y1, x2, y2)\n    p.circle(x1, y1, 10)\n    p.circle(x2, y2, 10)\n    \n    p.circle(lerp_x, lerp_y, 2)\n\n    return({x: lerp_x, y: lerp_y})\n    \n  }\n\n  \n\n}\n\n\n\nnew p5(sketch)\n\n","cursor":1772},{"id":"3kcxvr","type":"default","code":"","active":false,"focus":false,"focused":false,"output":"setTimeout(() => {\n  document.querySelector(\"canvas\").style.transform = `\n  translateX(-25%)\n  translateY(-32%)\n  scale(.35)`\n  \n  document.querySelector(\"canvas\").style.filter = ` invert()`}, 100)","cursor":188}],"fold":false,"focus":false}]}