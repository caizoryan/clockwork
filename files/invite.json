{"blocks":[{"type":"group","output":"let host = \"https://caizoryan-receiveandsavepoints.web.val.run/\"\n\nasync function send_points(name,points) {\n  return await fetch(host + name, {\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    method: \"POST\",\n    \n    body: JSON.stringify({\n      points: points\n    }),\n    \n  }).then((res) => res.json())\n}\n\nasync function get_points(name) {\n  return await fetch(host + name).then((res) => res.json())\n}\n\n// send_points([[0, 1],[0,3]]).then((res) => console.log(res))\n// get_points([[0, 1],[0,3]]).then((res) => console.log(res))\n\nlet c = document.createElement(\"canvas\")\nc.id=\"sketchpad\"\nc.style.border=\"1px solid black\"\n\nlet canvas, context\n\n\nlet color = (val) => {\n  let updates = []\n  let red_value = val \n  let red_label = document.createElement(\"span\")\n  red_label.innerText = red_value\n  let red_slider = document.createElement(\"input\")\n  red_slider.type = \"range\"\n  red_slider.max = 255\n  red_slider.value = val\n  red_slider.oninput = (e) => {\n    red_value = e.target.value\n    red_label.innerText = red_value\n    updates.forEach(e=>e(red_value))\n  }\n  \n  let red = document.createElement(\"div\")\n  red.appendChild(red_slider)\n  red.appendChild(red_label)\n\n  return {\n    el:red, value: () =>  red_value ,subscribe: (update) => updates.push(update)\n  }\n}\n\n\nlet red = color(255)\nlet green = color(255)\nlet blue = color(0)\n\n\nlet save = document.createElement(\"button\")\nsave.innerText=\"Save\"\nsave.onclick = () => {\n  send_points(\"aaryan\", points).then((res) => console.log(res))\n}\n\nlet rgb = document.createElement(\"div\")\nrgb.appendChild(red.el)\nrgb.appendChild(green.el)\nrgb.appendChild(blue.el)\n\nlet color_out = document.createElement(\"div\")\n\nconst update_color = (r, g, b) => color_out.style.background = `rgb(${r}, ${g}, ${b})`\nconst on_color_change = () => update_color(red.value(), green.value(), blue.value())\non_color_change()\n\nred.subscribe(on_color_change)\nblue.subscribe(on_color_change)\ngreen.subscribe(on_color_change)\n\n\nlet controls = document.createElement(\"div\")\ncontrols.style.display=\"grid\"\ncontrols.style.gridTemplateColumns=\"1fr 2fr 4fr\"\ncontrols.style.gridGap=\"50px\"\n\nlet points = []\nlet undo_stack = []\nlet last_point = () => points[points.length-1]\n\nfunction undo() {\n  let u = points.pop()\n  if (u) undo_stack.push(u)\n\n  clear()\n  render_points(points)\n}\n\nfunction redo(){\n  let r = undo_stack.pop()\n  if (r) points.push(r)\n  \n  clear()\n  render_points(points)\n}\n\nlet undo_btn = document.createElement(\"button\")\nundo_btn.innerText=\"undo\"\nundo_btn.onclick = () => { undo() }\n\nlet redo_btn = document.createElement(\"button\")\nredo_btn.innerText=\"redo\"\nredo_btn.onclick = () => { redo() }\n\ncontrols.appendChild(save)\ncontrols.appendChild(color_out)\ncontrols.appendChild(rgb)\ncontrols.appendChild(undo_btn)\ncontrols.appendChild(redo_btn)\n\ndocument.body.appendChild(c)\ndocument.body.appendChild(controls)\n\n\n// add to stroke\nfunction add_to_stroke(x, y){\n  if (points.length > 0) last_point().points.push([x, y])\n}\n\nfunction new_stroke(color =\"green\"){\n  return {\n    color: color,\n    points : []\n  }\n}\n\nfunction clear(){\n  context.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nlet ss = 1\n\nfunction render_points(points, slow=false) {\n  if (!slow) points.forEach(draw_stroke)\n  else {\n    let last = 0\n    points.forEach((p) => {\n      \n      setTimeout(()=>{\n        draw_animated_stroke(p)\n      },last+ss)\n                   \n      last+=p.points.length*ss+5\n    }\n    )}\n}\n\nfunction draw_animated_stroke(stroke) {\n  let first = stroke.points[0]\n  \n  context.beginPath();\n  context.strokeStyle = stroke.color\n  context.moveTo(first[0], first[1])\n  \n  stroke.points.forEach((e, i) => {\n    let [x, y] = e\n    setTimeout(() =>{\n      context.lineTo(x, y);\n      context.stroke();\n    }, i*ss)\n  })\n}\n\nfunction draw_stroke(stroke) {\n  let first = stroke.points[0]\n  \n  context.beginPath();\n  context.strokeStyle = stroke.color\n  context.moveTo(first[0], first[1])\n  \n  stroke.points.forEach((e) => {\n    let [x, y] = e\n    context.lineTo(x, y);\n    context.stroke();\n  })\n  \n}\nwindow.addEventListener('load', async function () {\n  // get the canvas element and its context\n  canvas = document.getElementById('sketchpad');\n  context = canvas.getContext('2d');\n  var isIdle = true;\n\n  context.canvas.width = \"500\"\n  context.canvas.height = \"500\"\n  \n  let pp = await get_points(\"aaryan\")\n  points = pp.points\n  render_points(points, true)\n  \n  function drawstart(event) {\n    context.beginPath();\n\n    if (points.length <= 0 \n        || last_point().points.length != 0\n       ) \n    {\n      points.push(\n        new_stroke(`rgb(${red.value()}, ${green.value()},${blue.value()})` )\n      )\n    }\n    context.strokeStyle = last_point().color\n    \n    let x = event.pageX - canvas.offsetLeft\n    let y = event.pageY - canvas.offsetTop\n\n    add_to_stroke(x, y)\n    \n    context.moveTo(x, y);\n    isIdle = false;\n  }\n  \n  function drawmove(event) {\n    if (isIdle) return;\n    \n    let x = event.pageX - canvas.offsetLeft\n    let y = event.pageY - canvas.offsetTop\n\n    add_to_stroke(x, y)\n    \n    context.lineTo(x, y);\n    context.stroke();\n  }\n  \n  function drawend(event) {\n    if (isIdle) return;\n    drawmove(event);\n    isIdle = true;\n\n    console.log(\"ok\", points)\n  }\n  \n  function touchstart(event) { drawstart(event.touches[0]) }\n  function touchmove(event) { drawmove(event.touches[0]); event.preventDefault(); }\n  function touchend(event) { drawend(event.changedTouches[0]) }\n\n  canvas.addEventListener('touchstart', touchstart, false);\n  canvas.addEventListener('touchmove', touchmove, false);\n  canvas.addEventListener('touchend', touchend, false);        \n\n  canvas.addEventListener('mousedown', drawstart, false);\n  canvas.addEventListener('mousemove', drawmove, false);\n  canvas.addEventListener('mouseup', drawend, false);\n\n}, false);","blocks":[{"id":"in2sf","type":"default","code":"","active":false,"focus":false,"focused":false,"output":"let host = \"https://caizoryan-receiveandsavepoints.web.val.run/\"\n\nasync function send_points(name,points) {\n  return await fetch(host + name, {\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    method: \"POST\",\n    \n    body: JSON.stringify({\n      points: points\n    }),\n    \n  }).then((res) => res.json())\n}\n\nasync function get_points(name) {\n  return await fetch(host + name).then((res) => res.json())\n}\n\n// send_points([[0, 1],[0,3]]).then((res) => console.log(res))\n// get_points([[0, 1],[0,3]]).then((res) => console.log(res))\n\nlet c = document.createElement(\"canvas\")\nc.id=\"sketchpad\"\nc.style.border=\"1px solid black\"\n\nlet canvas, context\n\n\nlet color = (val) => {\n  let updates = []\n  let red_value = val \n  let red_label = document.createElement(\"span\")\n  red_label.innerText = red_value\n  let red_slider = document.createElement(\"input\")\n  red_slider.type = \"range\"\n  red_slider.max = 255\n  red_slider.value = val\n  red_slider.oninput = (e) => {\n    red_value = e.target.value\n    red_label.innerText = red_value\n    updates.forEach(e=>e(red_value))\n  }\n  \n  let red = document.createElement(\"div\")\n  red.appendChild(red_slider)\n  red.appendChild(red_label)\n\n  return {\n    el:red, value: () =>  red_value ,subscribe: (update) => updates.push(update)\n  }\n}\n\n\nlet red = color(255)\nlet green = color(255)\nlet blue = color(0)\n\n\nlet save = document.createElement(\"button\")\nsave.innerText=\"Save\"\nsave.onclick = () => {\n  send_points(\"aaryan\", points).then((res) => console.log(res))\n}\n\nlet rgb = document.createElement(\"div\")\nrgb.appendChild(red.el)\nrgb.appendChild(green.el)\nrgb.appendChild(blue.el)\n\nlet color_out = document.createElement(\"div\")\n\nconst update_color = (r, g, b) => color_out.style.background = `rgb(${r}, ${g}, ${b})`\nconst on_color_change = () => update_color(red.value(), green.value(), blue.value())\non_color_change()\n\nred.subscribe(on_color_change)\nblue.subscribe(on_color_change)\ngreen.subscribe(on_color_change)\n\n\nlet controls = document.createElement(\"div\")\ncontrols.style.display=\"grid\"\ncontrols.style.gridTemplateColumns=\"1fr 2fr 4fr\"\ncontrols.style.gridGap=\"50px\"\n\nlet points = []\nlet undo_stack = []\nlet last_point = () => points[points.length-1]\n\nfunction undo() {\n  let u = points.pop()\n  if (u) undo_stack.push(u)\n\n  clear()\n  render_points(points)\n}\n\nfunction redo(){\n  let r = undo_stack.pop()\n  if (r) points.push(r)\n  \n  clear()\n  render_points(points)\n}\n\nlet undo_btn = document.createElement(\"button\")\nundo_btn.innerText=\"undo\"\nundo_btn.onclick = () => { undo() }\n\nlet redo_btn = document.createElement(\"button\")\nredo_btn.innerText=\"redo\"\nredo_btn.onclick = () => { redo() }\n\ncontrols.appendChild(save)\ncontrols.appendChild(color_out)\ncontrols.appendChild(rgb)\ncontrols.appendChild(undo_btn)\ncontrols.appendChild(redo_btn)\n\ndocument.body.appendChild(c)\ndocument.body.appendChild(controls)\n\n\n// add to stroke\nfunction add_to_stroke(x, y){\n  if (points.length > 0) last_point().points.push([x, y])\n}\n\nfunction new_stroke(color =\"green\"){\n  return {\n    color: color,\n    points : []\n  }\n}\n\nfunction clear(){\n  context.clearRect(0, 0, canvas.width, canvas.height);\n}\n\nlet ss = 1\n\nfunction render_points(points, slow=false) {\n  if (!slow) points.forEach(draw_stroke)\n  else {\n    let last = 0\n    points.forEach((p) => {\n      \n      setTimeout(()=>{\n        draw_animated_stroke(p)\n      },last+ss)\n                   \n      last+=p.points.length*ss+5\n    }\n    )}\n}\n\nfunction draw_animated_stroke(stroke) {\n  let first = stroke.points[0]\n  \n  context.beginPath();\n  context.strokeStyle = stroke.color\n  context.moveTo(first[0], first[1])\n  \n  stroke.points.forEach((e, i) => {\n    let [x, y] = e\n    setTimeout(() =>{\n      context.lineTo(x, y);\n      context.stroke();\n    }, i*ss)\n  })\n}\n\nfunction draw_stroke(stroke) {\n  let first = stroke.points[0]\n  \n  context.beginPath();\n  context.strokeStyle = stroke.color\n  context.moveTo(first[0], first[1])\n  \n  stroke.points.forEach((e) => {\n    let [x, y] = e\n    context.lineTo(x, y);\n    context.stroke();\n  })\n  \n}","cursor":3493},{"id":"07uc4","type":"default","code":"","active":false,"focus":false,"focused":false,"output":"window.addEventListener('load', async function () {\n  // get the canvas element and its context\n  canvas = document.getElementById('sketchpad');\n  context = canvas.getContext('2d');\n  var isIdle = true;\n\n  context.canvas.width = \"500\"\n  context.canvas.height = \"500\"\n  \n  let pp = await get_points(\"aaryan\")\n  points = pp.points\n  render_points(points, true)\n  \n  function drawstart(event) {\n    context.beginPath();\n\n    if (points.length <= 0 \n        || last_point().points.length != 0\n       ) \n    {\n      points.push(\n        new_stroke(`rgb(${red.value()}, ${green.value()},${blue.value()})` )\n      )\n    }\n    context.strokeStyle = last_point().color\n    \n    let x = event.pageX - canvas.offsetLeft\n    let y = event.pageY - canvas.offsetTop\n\n    add_to_stroke(x, y)\n    \n    context.moveTo(x, y);\n    isIdle = false;\n  }\n  \n  function drawmove(event) {\n    if (isIdle) return;\n    \n    let x = event.pageX - canvas.offsetLeft\n    let y = event.pageY - canvas.offsetTop\n\n    add_to_stroke(x, y)\n    \n    context.lineTo(x, y);\n    context.stroke();\n  }\n  \n  function drawend(event) {\n    if (isIdle) return;\n    drawmove(event);\n    isIdle = true;\n\n    console.log(\"ok\", points)\n  }\n  \n  function touchstart(event) { drawstart(event.touches[0]) }\n  function touchmove(event) { drawmove(event.touches[0]); event.preventDefault(); }\n  function touchend(event) { drawend(event.changedTouches[0]) }\n\n  canvas.addEventListener('touchstart', touchstart, false);\n  canvas.addEventListener('touchmove', touchmove, false);\n  canvas.addEventListener('touchend', touchend, false);        \n\n  canvas.addEventListener('mousedown', drawstart, false);\n  canvas.addEventListener('mousemove', drawmove, false);\n  canvas.addEventListener('mouseup', drawend, false);\n\n}, false);","cursor":356}],"fold":false,"focus":false}]}