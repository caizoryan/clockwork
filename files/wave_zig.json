{"blocks":[{"type":"group","output":"const raw_tiles_2 = [\n  {\n    \"src\": \"./tiles_zig/0.png\",\n    \"sockets\": [\n      \"111\",\n      \"000\",\n      \"000\",\n      \"001\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/1.png\",\n    \"sockets\": [\n      \"000\",\n      \"111\",\n      \"000\",\n      \"101\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/2.png\",\n    \"sockets\": [\n      \"010\",\n      \"000\",\n      \"010\",\n      \"000\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/3.png\",\n    \"sockets\": [\n      \"111\",\n      \"111\",\n      \"000\",\n      \"000\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/4.png\",\n    \"sockets\": [\n      \"000\",\n      \"101\",\n      \"000\",\n      \"000\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/5.png\",\n    \"sockets\": [\n      \"010\",\n      \"000\",\n      \"101\",\n      \"101\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/6.png\",\n    \"sockets\": [\n      \"110\",\n      \"000\",\n      \"010\",\n      \"000\"\n    ]\n  }\n]\nconst raw_tiles = [\n]\n// OPTIONS ARE INDEXES\n// SOCKETS ARE OBJECTS\n\nlet DIM = 8 \nlet rows = DIM\nlet cols = DIM\n\nlet grid = []\n  \nfunction Cell(options, collapsed = false) {\n  return {\n    options,\n    collapsed\n  }\n}\n\nfunction Tile(imag, sockets, p) {\n  let obj_sockets = {\n    TOP: sockets[0],\n    RIGHT: sockets[1],\n    BOTTOM: sockets[2],\n    LEFT: sockets[3],\n  }\n  \n  function rotate(num) {\n    // Draw new tile\n    const wi = p.width / rows;\n    const he = p.height / cols;\n    const newImg = p.createGraphics(wi, he);\n\n    newImg.imageMode(p.CENTER)\n    newImg.translate(wi / 2, he / 2);\n    newImg.rotate(newImg.HALF_PI * num);\n    newImg.image(imag, 0, 0, wi, he);\n  \n    // Rotate edges\n    const newSockets = [];\n    const len = sockets.length;\n    for (let i = 0; i < len; i++) {\n      newSockets[i] = sockets[(i - num + len) % len];\n    }\n    \n\n    return Tile(newImg, newSockets, p);\n  }\n  \n  return {\n    image:imag, sockets: obj_sockets, rotate\n  }\n}\n\nfunction initGrid(grid, rows, cols, options) {\n  if (!options) options = tiles.map((e, i) => i)\n  for(let y = 0; y < rows; y++ ){\n    grid[y] = []\n    \n    for(let x = 0; x < cols; x++ ){\n      grid[y][x] = Cell(options)\n    }\n  }\n}\n\nfunction neighbour(grid) {\n  const left = (x, y) =>\n    x > 0 \n      ? grid[y][x-1]\n      : null\n  \n  const right = (x, y) =>\n    x < grid[y].length - 1\n      ? grid[y][x + 1]\n      : null\n  \n  const top = (x, y) =>\n    y > 0 \n      ? grid[y-1][x]\n      : null\n  \n  const bottom = (x, y) =>\n    y < grid.length - 1\n      ? grid[y + 1][x]\n      : null\n\n  return {\n    left, right, top, bottom,\n    \n    LEFT:left, \n    RIGHT:right,\n    TOP:top,\n    BOTTOM :bottom}\n}\n\nfunction step(grid,p) {\n  // will go through the grid\n  // compare neighbours and collect options\n  let n = neighbour(grid)\n  let option_sizes = []\n\n  for(let y = 0; y < rows; y++ ){\n    for(let x = 0; x < cols; x++ ){\n      let item = grid[y][x]\n      let test = new_item(item, x, y, n)\n\n      if(!item.collapsed){\n        let size = test.options.length\n        option_sizes.push(size)\n      }\n      \n      grid[y][x] = test\n    }\n  }\n\n  if (option_sizes.length == 0) {\n    p.noLoop()\n    return\n  }\n\n  let min = option_sizes.reduce(function (p, v) {\n    return ( p < v ? p : v );\n  });\n\n  if (min == 0) min = 1\n\n  // get all cells with least options and randomly select\n  let random = (arr) => {\n    let index = Math.floor(Math.random() * arr.length)\n    return arr[index]\n  }\n\n  let left = []\n  \n  for(let y = 0; y < rows; y++ ){\n    for(let x = 0; x < cols; x++ ){\n      let item = grid[y][x]\n      if (item.options.length == min) {\n        left.push({x, y})\n      }\n    }\n  }\n\n  let c = random(left)\n\n  if(c){\n    console.log(\"piclk\",c)\n    let item = grid[c.y][c.x]\n    grid[c.y][c.x].options = [random(item.options)]\n  }\n\n  else {\n    console.log(\"no pick\", c)\n  }\n}\n\n\n\nlet TOP = \"TOP\"\nlet RIGHT = \"RIGHT\" \nlet BOTTOM = \"BOTTOM\" \nlet LEFT = \"LEFT\" \n\nfunction collapsed_tile(cell) {\n  return tiles[cell.options[0]]\n}\n\nfunction reverseString(str) {\n  return str.split(\"\").reverse().join(\"\")\n}\n\nfunction compatible(a, b) {\n  return a == reverseString(b) \n}\n\nfunction opposite(side) {\n  if (side == TOP) return BOTTOM\n  if (side == BOTTOM) return TOP\n  if (side == RIGHT) return LEFT\n  if (side == LEFT) return RIGHT\n}\nfunction check_of(x, y, side, options, neighbour) {\n  \n  let neib = neighbour[side](x, y)\n  let ret_options = [...options]\n  \n  if (neib && neib.collapsed) {\n    let neib_tile = collapsed_tile(neib)\n\n    ret_options = options.filter((index) => {\n      let me = tiles[index]\n      let a = me.sockets[side]\n      let b = neib_tile.sockets[opposite(side)]\n\n      return compatible(a, b)\n    })\n  }\n  \n  return ret_options\n}\n\nfunction new_item(item, x, y, neighbour){\n  let options = item.options\n  \n  // top\n  options = check_of(x, y, \"TOP\", options, neighbour)  \n  options = check_of(x, y, \"RIGHT\", options, neighbour)  \n  options = check_of(x, y, \"BOTTOM\", options, neighbour)  \n  options = check_of(x, y, \"LEFT\", options, neighbour)  \n  \n  return Cell(options, item.collapsed)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet tiles = []\n\nlet sketch = (p) => {\n  p.preload = () => {\n    \n    raw_tiles_2.forEach((tile) => {\n      let image = p.loadImage(tile.src)\n      let sockets = tile.sockets\n      tiles.push(Tile(image, sockets, p))\n    })\n    raw_tiles.forEach((tile) => {\n      let image = p.loadImage(tile.src)\n      let sockets = tile.sockets\n      tiles.push(Tile(image, sockets, p))\n    })\n    \n  }\n  \n  p.setup = () => {\n    p.createCanvas(800,800);\n    p.background(\"black\")\n\n    tiles.forEach((tile) => {\n      tiles.push(tile.rotate(1))\n      tiles.push(tile.rotate(2))\n      tiles.push(tile.rotate(3))\n    })\n    \n    initGrid(grid, rows, cols)\n    \n    grid[2][0] = Cell([2])\n\n    // document.querySelector(\"canvas\").style.filter = \"invert(1) blur(2px) contrast(.4)\"\n\n    \n  }\n\n  p.draw = () => {\n    // p.tint(\"red\")\n    p.noStroke()\n    draw_grid()\n    step(grid, p)\n  }\n\n  p.mouseClicked = () => {\n    p.redraw()\n  }\n\n  function draw_grid() {\n    let wid = p.width\n    let hei = p.height \n\n    let cell_w = p.width / cols\n    let cell_h = p.height / rows\n\n    for(let y = 0; y < rows; y++ ){\n      for(let x = 0; x < cols; x++ ){\n        let item = grid[y][x]\n        if (item.options.length == 1 && !item.collapsed){\n          // p.rect(x * cell_w, y*cell_h, cell_w, cell_h)\n          p.image(\n            tiles[item.options[0]].image,\n            x * cell_w, y*cell_h, cell_w, cell_h)\n          \n          grid[y][x] = Cell(item.options, true, true)\n        }\n          \n        else if (!item.collapsed && item.options.length > 0) {\n          let total = tiles.length\n          let percent = item.options.length / total * 455\n          let text = item.options.join(\", \")\n          p.fill(percent)\n          p.rect(x * cell_w, y*cell_h, cell_w, cell_h)\n          p.fill(\"yellow\")\n          p.text(text,x * cell_w, y*cell_h, cell_w, cell_h)\n        }\n        \n      }\n    }\n  }\n}\n\n\n\n\n //  {\n\t// \tsrc: \"./tiles_vine/0.png\",\n\t// \tsockets: [\"000\", \"110\", \"000\", \"110\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/1.png\",\n\t// \tsockets: [\"000\", \"001\", \"000\", \"100\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/2.png\",\n\t// \tsockets: [\"100\", \"100\", \"001\", \"001\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/3.png\",\n\t// \tsockets: [\"000\", \"010\", \"000\", \"010\"]\n\t// },\n\t// {\n\t// \tsrc: \"./tiles_vine/4.png\",\n\t// \tsockets: [\"101\", \"000\", \"000\", \"101\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/5.png\",\n\t// \tsockets: [\"100\", \"001\", \"000\", \"000\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/6.png\",\n\t// \tsockets: [\"001\", \"001\", \"100\", \"100\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/7.png\",\n\t// \tsockets: [\"101\", \"000\", \"101\", \"000\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/8.png\",\n\t// \tsockets: [\"100\", \"000\", \"001\", \"000\"]\n\t// },\nnew p5(sketch)","blocks":[{"id":"pis60i","type":"group","code":"","active":false,"focus":false,"output":"const raw_tiles_2 = [\n  {\n    \"src\": \"./tiles_zig/0.png\",\n    \"sockets\": [\n      \"111\",\n      \"000\",\n      \"000\",\n      \"001\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/1.png\",\n    \"sockets\": [\n      \"000\",\n      \"111\",\n      \"000\",\n      \"101\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/2.png\",\n    \"sockets\": [\n      \"010\",\n      \"000\",\n      \"010\",\n      \"000\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/3.png\",\n    \"sockets\": [\n      \"111\",\n      \"111\",\n      \"000\",\n      \"000\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/4.png\",\n    \"sockets\": [\n      \"000\",\n      \"101\",\n      \"000\",\n      \"000\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/5.png\",\n    \"sockets\": [\n      \"010\",\n      \"000\",\n      \"101\",\n      \"101\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/6.png\",\n    \"sockets\": [\n      \"110\",\n      \"000\",\n      \"010\",\n      \"000\"\n    ]\n  }\n]\nconst raw_tiles = [\n]","blocks":[{"id":"x1kh5","type":"wave","code":"","active":false,"focus":false,"focused":false,"cursor":93,"source":"[\n  {\n    \"src\": \"./tiles_zig/0.png\",\n    \"sockets\": [\n      \"111\",\n      \"000\",\n      \"000\",\n      \"001\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/1.png\",\n    \"sockets\": [\n      \"000\",\n      \"111\",\n      \"000\",\n      \"101\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/2.png\",\n    \"sockets\": [\n      \"010\",\n      \"000\",\n      \"010\",\n      \"000\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/3.png\",\n    \"sockets\": [\n      \"111\",\n      \"111\",\n      \"000\",\n      \"000\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/4.png\",\n    \"sockets\": [\n      \"000\",\n      \"101\",\n      \"000\",\n      \"000\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/5.png\",\n    \"sockets\": [\n      \"010\",\n      \"000\",\n      \"101\",\n      \"101\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/6.png\",\n    \"sockets\": [\n      \"110\",\n      \"000\",\n      \"010\",\n      \"000\"\n    ]\n  }\n]","output":"const raw_tiles_2 = [\n  {\n    \"src\": \"./tiles_zig/0.png\",\n    \"sockets\": [\n      \"111\",\n      \"000\",\n      \"000\",\n      \"001\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/1.png\",\n    \"sockets\": [\n      \"000\",\n      \"111\",\n      \"000\",\n      \"101\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/2.png\",\n    \"sockets\": [\n      \"010\",\n      \"000\",\n      \"010\",\n      \"000\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/3.png\",\n    \"sockets\": [\n      \"111\",\n      \"111\",\n      \"000\",\n      \"000\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/4.png\",\n    \"sockets\": [\n      \"000\",\n      \"101\",\n      \"000\",\n      \"000\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/5.png\",\n    \"sockets\": [\n      \"010\",\n      \"000\",\n      \"101\",\n      \"101\"\n    ]\n  },\n  {\n    \"src\": \"./tiles_zig/6.png\",\n    \"sockets\": [\n      \"110\",\n      \"000\",\n      \"010\",\n      \"000\"\n    ]\n  }\n]","editor_showing":true,"name":"raw_tiles_2"},{"id":"kph9s","type":"wave","code":"","active":false,"output":"const raw_tiles = [\n]","name":"raw_tiles","tiles":[{"src":"./tiles_vine/4.png","sockets":["222","000","000","101"]},{"src":"./tiles_vine/7.png","sockets":["101","000","101","000"]},{"src":"./tiles_vine/5.png","sockets":["100","001","000","000"]}],"editor_showing":true,"focused":false,"cursor":0,"source":"[\n]","focus":false}],"fold":false},{"id":"k9b1y","type":"group","code":"","active":false,"focus":false,"output":"// OPTIONS ARE INDEXES\n// SOCKETS ARE OBJECTS\n\nlet DIM = 8 \nlet rows = DIM\nlet cols = DIM\n\nlet grid = []\n  \nfunction Cell(options, collapsed = false) {\n  return {\n    options,\n    collapsed\n  }\n}\n\nfunction Tile(imag, sockets, p) {\n  let obj_sockets = {\n    TOP: sockets[0],\n    RIGHT: sockets[1],\n    BOTTOM: sockets[2],\n    LEFT: sockets[3],\n  }\n  \n  function rotate(num) {\n    // Draw new tile\n    const wi = p.width / rows;\n    const he = p.height / cols;\n    const newImg = p.createGraphics(wi, he);\n\n    newImg.imageMode(p.CENTER)\n    newImg.translate(wi / 2, he / 2);\n    newImg.rotate(newImg.HALF_PI * num);\n    newImg.image(imag, 0, 0, wi, he);\n  \n    // Rotate edges\n    const newSockets = [];\n    const len = sockets.length;\n    for (let i = 0; i < len; i++) {\n      newSockets[i] = sockets[(i - num + len) % len];\n    }\n    \n\n    return Tile(newImg, newSockets, p);\n  }\n  \n  return {\n    image:imag, sockets: obj_sockets, rotate\n  }\n}\n\nfunction initGrid(grid, rows, cols, options) {\n  if (!options) options = tiles.map((e, i) => i)\n  for(let y = 0; y < rows; y++ ){\n    grid[y] = []\n    \n    for(let x = 0; x < cols; x++ ){\n      grid[y][x] = Cell(options)\n    }\n  }\n}\n\nfunction neighbour(grid) {\n  const left = (x, y) =>\n    x > 0 \n      ? grid[y][x-1]\n      : null\n  \n  const right = (x, y) =>\n    x < grid[y].length - 1\n      ? grid[y][x + 1]\n      : null\n  \n  const top = (x, y) =>\n    y > 0 \n      ? grid[y-1][x]\n      : null\n  \n  const bottom = (x, y) =>\n    y < grid.length - 1\n      ? grid[y + 1][x]\n      : null\n\n  return {\n    left, right, top, bottom,\n    \n    LEFT:left, \n    RIGHT:right,\n    TOP:top,\n    BOTTOM :bottom}\n}\n\nfunction step(grid,p) {\n  // will go through the grid\n  // compare neighbours and collect options\n  let n = neighbour(grid)\n  let option_sizes = []\n\n  for(let y = 0; y < rows; y++ ){\n    for(let x = 0; x < cols; x++ ){\n      let item = grid[y][x]\n      let test = new_item(item, x, y, n)\n\n      if(!item.collapsed){\n        let size = test.options.length\n        option_sizes.push(size)\n      }\n      \n      grid[y][x] = test\n    }\n  }\n\n  if (option_sizes.length == 0) {\n    p.noLoop()\n    return\n  }\n\n  let min = option_sizes.reduce(function (p, v) {\n    return ( p < v ? p : v );\n  });\n\n  if (min == 0) min = 1\n\n  // get all cells with least options and randomly select\n  let random = (arr) => {\n    let index = Math.floor(Math.random() * arr.length)\n    return arr[index]\n  }\n\n  let left = []\n  \n  for(let y = 0; y < rows; y++ ){\n    for(let x = 0; x < cols; x++ ){\n      let item = grid[y][x]\n      if (item.options.length == min) {\n        left.push({x, y})\n      }\n    }\n  }\n\n  let c = random(left)\n\n  if(c){\n    console.log(\"piclk\",c)\n    let item = grid[c.y][c.x]\n    grid[c.y][c.x].options = [random(item.options)]\n  }\n\n  else {\n    console.log(\"no pick\", c)\n  }\n}\n\n\n\nlet TOP = \"TOP\"\nlet RIGHT = \"RIGHT\" \nlet BOTTOM = \"BOTTOM\" \nlet LEFT = \"LEFT\" \n\nfunction collapsed_tile(cell) {\n  return tiles[cell.options[0]]\n}\n\nfunction reverseString(str) {\n  return str.split(\"\").reverse().join(\"\")\n}\n\nfunction compatible(a, b) {\n  return a == reverseString(b) \n}\n\nfunction opposite(side) {\n  if (side == TOP) return BOTTOM\n  if (side == BOTTOM) return TOP\n  if (side == RIGHT) return LEFT\n  if (side == LEFT) return RIGHT\n}\nfunction check_of(x, y, side, options, neighbour) {\n  \n  let neib = neighbour[side](x, y)\n  let ret_options = [...options]\n  \n  if (neib && neib.collapsed) {\n    let neib_tile = collapsed_tile(neib)\n\n    ret_options = options.filter((index) => {\n      let me = tiles[index]\n      let a = me.sockets[side]\n      let b = neib_tile.sockets[opposite(side)]\n\n      return compatible(a, b)\n    })\n  }\n  \n  return ret_options\n}\n\nfunction new_item(item, x, y, neighbour){\n  let options = item.options\n  \n  // top\n  options = check_of(x, y, \"TOP\", options, neighbour)  \n  options = check_of(x, y, \"RIGHT\", options, neighbour)  \n  options = check_of(x, y, \"BOTTOM\", options, neighbour)  \n  options = check_of(x, y, \"LEFT\", options, neighbour)  \n  \n  return Cell(options, item.collapsed)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet tiles = []\n\nlet sketch = (p) => {\n  p.preload = () => {\n    \n    raw_tiles_2.forEach((tile) => {\n      let image = p.loadImage(tile.src)\n      let sockets = tile.sockets\n      tiles.push(Tile(image, sockets, p))\n    })\n    raw_tiles.forEach((tile) => {\n      let image = p.loadImage(tile.src)\n      let sockets = tile.sockets\n      tiles.push(Tile(image, sockets, p))\n    })\n    \n  }\n  \n  p.setup = () => {\n    p.createCanvas(800,800);\n    p.background(\"black\")\n\n    tiles.forEach((tile) => {\n      tiles.push(tile.rotate(1))\n      tiles.push(tile.rotate(2))\n      tiles.push(tile.rotate(3))\n    })\n    \n    initGrid(grid, rows, cols)\n    \n    grid[2][0] = Cell([2])\n\n    // document.querySelector(\"canvas\").style.filter = \"invert(1) blur(2px) contrast(.4)\"\n\n    \n  }\n\n  p.draw = () => {\n    // p.tint(\"red\")\n    p.noStroke()\n    draw_grid()\n    step(grid, p)\n  }\n\n  p.mouseClicked = () => {\n    p.redraw()\n  }\n\n  function draw_grid() {\n    let wid = p.width\n    let hei = p.height \n\n    let cell_w = p.width / cols\n    let cell_h = p.height / rows\n\n    for(let y = 0; y < rows; y++ ){\n      for(let x = 0; x < cols; x++ ){\n        let item = grid[y][x]\n        if (item.options.length == 1 && !item.collapsed){\n          // p.rect(x * cell_w, y*cell_h, cell_w, cell_h)\n          p.image(\n            tiles[item.options[0]].image,\n            x * cell_w, y*cell_h, cell_w, cell_h)\n          \n          grid[y][x] = Cell(item.options, true, true)\n        }\n          \n        else if (!item.collapsed && item.options.length > 0) {\n          let total = tiles.length\n          let percent = item.options.length / total * 455\n          let text = item.options.join(\", \")\n          p.fill(percent)\n          p.rect(x * cell_w, y*cell_h, cell_w, cell_h)\n          p.fill(\"yellow\")\n          p.text(text,x * cell_w, y*cell_h, cell_w, cell_h)\n        }\n        \n      }\n    }\n  }\n}\n\n\n","blocks":[{"id":"wimfh","type":"default","code":"","active":false,"focus":false,"focused":false,"output":"// OPTIONS ARE INDEXES\n// SOCKETS ARE OBJECTS\n\nlet DIM = 8 \nlet rows = DIM\nlet cols = DIM\n\nlet grid = []\n  \nfunction Cell(options, collapsed = false) {\n  return {\n    options,\n    collapsed\n  }\n}\n\nfunction Tile(imag, sockets, p) {\n  let obj_sockets = {\n    TOP: sockets[0],\n    RIGHT: sockets[1],\n    BOTTOM: sockets[2],\n    LEFT: sockets[3],\n  }\n  \n  function rotate(num) {\n    // Draw new tile\n    const wi = p.width / rows;\n    const he = p.height / cols;\n    const newImg = p.createGraphics(wi, he);\n\n    newImg.imageMode(p.CENTER)\n    newImg.translate(wi / 2, he / 2);\n    newImg.rotate(newImg.HALF_PI * num);\n    newImg.image(imag, 0, 0, wi, he);\n  \n    // Rotate edges\n    const newSockets = [];\n    const len = sockets.length;\n    for (let i = 0; i < len; i++) {\n      newSockets[i] = sockets[(i - num + len) % len];\n    }\n    \n\n    return Tile(newImg, newSockets, p);\n  }\n  \n  return {\n    image:imag, sockets: obj_sockets, rotate\n  }\n}\n\nfunction initGrid(grid, rows, cols, options) {\n  if (!options) options = tiles.map((e, i) => i)\n  for(let y = 0; y < rows; y++ ){\n    grid[y] = []\n    \n    for(let x = 0; x < cols; x++ ){\n      grid[y][x] = Cell(options)\n    }\n  }\n}\n\nfunction neighbour(grid) {\n  const left = (x, y) =>\n    x > 0 \n      ? grid[y][x-1]\n      : null\n  \n  const right = (x, y) =>\n    x < grid[y].length - 1\n      ? grid[y][x + 1]\n      : null\n  \n  const top = (x, y) =>\n    y > 0 \n      ? grid[y-1][x]\n      : null\n  \n  const bottom = (x, y) =>\n    y < grid.length - 1\n      ? grid[y + 1][x]\n      : null\n\n  return {\n    left, right, top, bottom,\n    \n    LEFT:left, \n    RIGHT:right,\n    TOP:top,\n    BOTTOM :bottom}\n}\n\nfunction step(grid,p) {\n  // will go through the grid\n  // compare neighbours and collect options\n  let n = neighbour(grid)\n  let option_sizes = []\n\n  for(let y = 0; y < rows; y++ ){\n    for(let x = 0; x < cols; x++ ){\n      let item = grid[y][x]\n      let test = new_item(item, x, y, n)\n\n      if(!item.collapsed){\n        let size = test.options.length\n        option_sizes.push(size)\n      }\n      \n      grid[y][x] = test\n    }\n  }\n\n  if (option_sizes.length == 0) {\n    p.noLoop()\n    return\n  }\n\n  let min = option_sizes.reduce(function (p, v) {\n    return ( p < v ? p : v );\n  });\n\n  if (min == 0) min = 1\n\n  // get all cells with least options and randomly select\n  let random = (arr) => {\n    let index = Math.floor(Math.random() * arr.length)\n    return arr[index]\n  }\n\n  let left = []\n  \n  for(let y = 0; y < rows; y++ ){\n    for(let x = 0; x < cols; x++ ){\n      let item = grid[y][x]\n      if (item.options.length == min) {\n        left.push({x, y})\n      }\n    }\n  }\n\n  let c = random(left)\n\n  if(c){\n    console.log(\"piclk\",c)\n    let item = grid[c.y][c.x]\n    grid[c.y][c.x].options = [random(item.options)]\n  }\n\n  else {\n    console.log(\"no pick\", c)\n  }\n}\n\n\n\nlet TOP = \"TOP\"\nlet RIGHT = \"RIGHT\" \nlet BOTTOM = \"BOTTOM\" \nlet LEFT = \"LEFT\" \n\nfunction collapsed_tile(cell) {\n  return tiles[cell.options[0]]\n}\n\nfunction reverseString(str) {\n  return str.split(\"\").reverse().join(\"\")\n}\n\nfunction compatible(a, b) {\n  return a == reverseString(b) \n}\n\nfunction opposite(side) {\n  if (side == TOP) return BOTTOM\n  if (side == BOTTOM) return TOP\n  if (side == RIGHT) return LEFT\n  if (side == LEFT) return RIGHT\n}\nfunction check_of(x, y, side, options, neighbour) {\n  \n  let neib = neighbour[side](x, y)\n  let ret_options = [...options]\n  \n  if (neib && neib.collapsed) {\n    let neib_tile = collapsed_tile(neib)\n\n    ret_options = options.filter((index) => {\n      let me = tiles[index]\n      let a = me.sockets[side]\n      let b = neib_tile.sockets[opposite(side)]\n\n      return compatible(a, b)\n    })\n  }\n  \n  return ret_options\n}\n\nfunction new_item(item, x, y, neighbour){\n  let options = item.options\n  \n  // top\n  options = check_of(x, y, \"TOP\", options, neighbour)  \n  options = check_of(x, y, \"RIGHT\", options, neighbour)  \n  options = check_of(x, y, \"BOTTOM\", options, neighbour)  \n  options = check_of(x, y, \"LEFT\", options, neighbour)  \n  \n  return Cell(options, item.collapsed)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","cursor":297},{"id":"fbxrb9","type":"default","code":"","active":false,"focus":false,"focused":false,"output":"let tiles = []\n\nlet sketch = (p) => {\n  p.preload = () => {\n    \n    raw_tiles_2.forEach((tile) => {\n      let image = p.loadImage(tile.src)\n      let sockets = tile.sockets\n      tiles.push(Tile(image, sockets, p))\n    })\n    raw_tiles.forEach((tile) => {\n      let image = p.loadImage(tile.src)\n      let sockets = tile.sockets\n      tiles.push(Tile(image, sockets, p))\n    })\n    \n  }\n  \n  p.setup = () => {\n    p.createCanvas(800,800);\n    p.background(\"black\")\n\n    tiles.forEach((tile) => {\n      tiles.push(tile.rotate(1))\n      tiles.push(tile.rotate(2))\n      tiles.push(tile.rotate(3))\n    })\n    \n    initGrid(grid, rows, cols)\n    \n    grid[2][0] = Cell([2])\n\n    // document.querySelector(\"canvas\").style.filter = \"invert(1) blur(2px) contrast(.4)\"\n\n    \n  }\n\n  p.draw = () => {\n    // p.tint(\"red\")\n    p.noStroke()\n    draw_grid()\n    step(grid, p)\n  }\n\n  p.mouseClicked = () => {\n    p.redraw()\n  }\n\n  function draw_grid() {\n    let wid = p.width\n    let hei = p.height \n\n    let cell_w = p.width / cols\n    let cell_h = p.height / rows\n\n    for(let y = 0; y < rows; y++ ){\n      for(let x = 0; x < cols; x++ ){\n        let item = grid[y][x]\n        if (item.options.length == 1 && !item.collapsed){\n          // p.rect(x * cell_w, y*cell_h, cell_w, cell_h)\n          p.image(\n            tiles[item.options[0]].image,\n            x * cell_w, y*cell_h, cell_w, cell_h)\n          \n          grid[y][x] = Cell(item.options, true, true)\n        }\n          \n        else if (!item.collapsed && item.options.length > 0) {\n          let total = tiles.length\n          let percent = item.options.length / total * 455\n          let text = item.options.join(\", \")\n          p.fill(percent)\n          p.rect(x * cell_w, y*cell_h, cell_w, cell_h)\n          p.fill(\"yellow\")\n          p.text(text,x * cell_w, y*cell_h, cell_w, cell_h)\n        }\n        \n      }\n    }\n  }\n}\n\n\n","cursor":0}],"fold":true},{"id":"1bqfy","type":"group","code":"","active":false,"focus":false,"output":"\n //  {\n\t// \tsrc: \"./tiles_vine/0.png\",\n\t// \tsockets: [\"000\", \"110\", \"000\", \"110\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/1.png\",\n\t// \tsockets: [\"000\", \"001\", \"000\", \"100\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/2.png\",\n\t// \tsockets: [\"100\", \"100\", \"001\", \"001\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/3.png\",\n\t// \tsockets: [\"000\", \"010\", \"000\", \"010\"]\n\t// },\n\t// {\n\t// \tsrc: \"./tiles_vine/4.png\",\n\t// \tsockets: [\"101\", \"000\", \"000\", \"101\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/5.png\",\n\t// \tsockets: [\"100\", \"001\", \"000\", \"000\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/6.png\",\n\t// \tsockets: [\"001\", \"001\", \"100\", \"100\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/7.png\",\n\t// \tsockets: [\"101\", \"000\", \"101\", \"000\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/8.png\",\n\t// \tsockets: [\"100\", \"000\", \"001\", \"000\"]\n\t// },","blocks":[{"id":"4kmy3g","type":"default","code":"","active":false,"focus":false,"focused":false,"output":"\n //  {\n\t// \tsrc: \"./tiles_vine/0.png\",\n\t// \tsockets: [\"000\", \"110\", \"000\", \"110\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/1.png\",\n\t// \tsockets: [\"000\", \"001\", \"000\", \"100\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/2.png\",\n\t// \tsockets: [\"100\", \"100\", \"001\", \"001\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/3.png\",\n\t// \tsockets: [\"000\", \"010\", \"000\", \"010\"]\n\t// },\n\t// {\n\t// \tsrc: \"./tiles_vine/4.png\",\n\t// \tsockets: [\"101\", \"000\", \"000\", \"101\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/5.png\",\n\t// \tsockets: [\"100\", \"001\", \"000\", \"000\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/6.png\",\n\t// \tsockets: [\"001\", \"001\", \"100\", \"100\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/7.png\",\n\t// \tsockets: [\"101\", \"000\", \"101\", \"000\"]\n\t// },\n\n\t// {\n\t// \tsrc: \"./tiles_vine/8.png\",\n\t// \tsockets: [\"100\", \"000\", \"001\", \"000\"]\n\t// },","cursor":0}],"fold":true},{"id":"9qc1vd","type":"default","code":"","active":false,"focus":false,"focused":false,"output":"new p5(sketch)","cursor":0}],"fold":false,"focus":false}]}