{"blocks":[{"type":"group","output":"// \nlet DIM = 8 \nlet rows = DIM\nlet cols = DIM\n\nlet grid = []\n\nlet raw_tiles = [\n  {\n    src: \"./tiles/0.png\",\n    sockets: [1,0,1,0]\n  },\n  {\n    src: \"./tiles/1.png\",\n    sockets: [1,1,1,0]\n  },\n  \n  {\n    src: \"./tiles/2.png\",\n    sockets: [1,1,0,1]\n  },\n  \n  {\n    src: \"./tiles/3.png\",\n    sockets: [1,0,1,0]\n  },\n  \n  {\n    src: \"./tiles/4.png\",\n    sockets: [1,0,0,1]\n  },\n  \n  {\n    src: \"./tiles/5.png\",\n    sockets: [0,1,1,1]\n  },\n  \n  {\n    src: \"./tiles/6.png\",\n    sockets: [1,0,0,1]\n  },\n  \n  {\n    src: \"./tiles/7.png\",\n    sockets: [0,0,1,1]\n  },\n  \n  {\n    src: \"./tiles/8.png\",\n    sockets: [1,1,1,0]\n  },\n  \n  {\n    src: \"./tiles/9.png\",\n    sockets: [1,0,0,1]\n  },\n  \n  {\n    src: \"./tiles/10.png\",\n    sockets: [0,1,0,1]\n  },\n  \n  {\n    src: \"./tiles/11.png\",\n    sockets: [1,1,0,0]\n  },\n  \n]\n\nlet raw_tiles_2 = [\n  {\n    src: \"./tiles_/0.png\",\n    sockets: [1,0,1,0]\n  },\n  {\n    src: \"./tiles_/1.png\",\n    sockets: [0,0,1,1]\n  },\n  \n  {\n    src: \"./tiles_/2.png\",\n    sockets: [1,1,0,1]\n  },\n  \n  {\n    src: \"./tiles_/3.png\",\n    sockets: [0,1,0,1]\n  },\n  \n  {\n    src: \"./tiles_/4.png\",\n    sockets: [1,1,1,0]\n  },\n  \n  {\n    src: \"./tiles_/5.png\",\n    sockets: [0,1,0,1]\n  },\n  \n  {\n    src: \"./tiles_/6.png\",\n    sockets: [1,0,0,1]\n  },\n  \n  {\n    src: \"./tiles_/7.png\",\n    sockets: [0,0,1,0]\n  },\n  \n  {\n    src: \"./tiles_/8.png\",\n    sockets: [1,1,0,0]\n  },\n  \n]\n\nfunction Cell(options, collapsed = false) {\n  return {\n    options,\n    collapsed\n  }\n}\n\nfunction Tile(imag, sockets, p) {\n  function rotate(num) {\n    // Draw new tile\n    const wi = p.width / rows;\n    const he = p.height / cols;\n    console.log(wi, he)\n    const newImg = p.createGraphics(wi, he);\n\n    newImg.imageMode(p.CENTER)\n    newImg.translate(wi / 2, he / 2);\n    newImg.rotate(newImg.HALF_PI * num);\n    newImg.image(imag, 0, 0, wi, he);\n  \n    // Rotate edges\n    const newSockets = [];\n    const len = sockets.length;\n    for (let i = 0; i < len; i++) {\n      newSockets[i] = sockets[(i - num + len) % len];\n    }\n\n    return Tile(newImg, newSockets, p);\n  }\n  \n  return {\n    image:imag, sockets, rotate\n  }\n}\n\nfunction initGrid(grid, rows, cols, options) {\n  if (!options) options = tiles.map((e, i) => i)\n  for(let y = 0; y < rows; y++ ){\n    grid[y] = []\n    \n    for(let x = 0; x < cols; x++ ){\n      grid[y][x] = Cell(options)\n    }\n  }\n}\n\nfunction neighbour(grid) {\n  const left = (x, y) =>\n    x > 0 \n      ? grid[y][x-1]\n      : null\n  \n  const right = (x, y) =>\n    x < grid[y].length - 1\n      ? grid[y][x + 1]\n      : null\n  \n  const top = (x, y) =>\n    y > 0 \n      ? grid[y-1][x]\n      : null\n  \n  const bottom = (x, y) =>\n    y < grid.length - 1\n      ? grid[y + 1][x]\n      : null\n\n  return {left, right, top, bottom}\n}\n\nfunction step(grid,p) {\n  // will go through the grid\n  // compare neighbours and collect options\n  let n = neighbour(grid)\n  let option_sizes = []\n\n  for(let y = 0; y < rows; y++ ){\n    for(let x = 0; x < cols; x++ ){\n      let item = grid[y][x]\n      let test = new_item(item, x, y, n)\n\n      if(!item.collapsed){\n        let size = test.options.length\n        option_sizes.push(size)\n      }\n      \n      grid[y][x] = test\n    }\n  }\n\n  if (option_sizes.length == 0) {\n    p.noLoop()\n    return\n  }\n\n  let min = option_sizes.reduce(function (p, v) {\n    return ( p < v ? p : v );\n  });\n\n  if (min == 0) min = 1\n\n  // get all cells with least options and randomly select\n  let random = (arr) => {\n    let index = Math.floor(Math.random() * arr.length)\n    return arr[index]\n  }\n\n  let left = []\n  \n  for(let y = 0; y < rows; y++ ){\n    for(let x = 0; x < cols; x++ ){\n      let item = grid[y][x]\n      if (item.options.length == min) {\n        left.push({x, y})\n      }\n    }\n  }\n\n  let c = random(left)\n\n  if(c){\n    let item = grid[c.y][c.x]\n    \n    grid[c.y][c.x].options = [random(item.options)]\n  }\n}\n\n\n\nlet TOP = 0\nlet RIGHT = 1\nlet BOTTOM = 2\nlet LEFT = 3\n\nfunction collapsed_tile(cell) {\n  return tiles[cell.options[0]]\n}\n\nfunction new_item(item, x, y, neighbour){\n  let options = item.options\n  \n  // top\n  let top = neighbour.top(x, y)\n  if (top && top.collapsed) {\n    let top_tile = collapsed_tile(top)\n    \n    options = options.filter((index) => {\n      let me = tiles[index]\n      let a = me.sockets[TOP]\n      let b = top_tile.sockets[BOTTOM]\n      \n      return a == b\n    })\n  }\n  \n  // Bottom\n  let bottom = neighbour.bottom(x, y)\n  if (bottom && bottom.collapsed) {\n    \n    let bottom_tile = collapsed_tile(bottom)\n    \n    options = options.filter((index) => {\n      let me = tiles[index]\n      let a = me.sockets[BOTTOM]\n      let b = bottom_tile.sockets[TOP]\n      \n      return a == b\n    })\n  }\n  \n  // Left\n  let left = neighbour.left(x, y)\n  if (left && left.collapsed) {\n    let left_tile = collapsed_tile(left)\n    \n    options = options.filter((index) => {\n      let me = tiles[index]\n      let a = me.sockets[LEFT]\n      let b = left_tile.sockets[RIGHT]\n      \n      return a == b\n    })\n  }\n  \n  // Right\n  let right = neighbour.right(x, y)\n  if (right && right.collapsed) {\n    let right_tile = collapsed_tile(right)\n    \n    options = options.filter((index) => {\n      let me = tiles[index]\n      let a = me.sockets[RIGHT]\n      let b = right_tile.sockets[LEFT]\n      \n      return a == b\n    })\n  }\n\n  return Cell(options, item.collapsed)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nlet tiles = []\n\nlet sketch = (p) => {\n  p.preload = () => {\n    \n    raw_tiles_2.forEach((tile) => {\n      let image = p.loadImage(tile.src)\n      let sockets = tile.sockets\n      tiles.push(Tile(image, sockets, p))\n    })\n    raw_tiles.forEach((tile) => {\n      let image = p.loadImage(tile.src)\n      let sockets = tile.sockets\n      tiles.push(Tile(image, sockets, p))\n    })\n    \n  }\n  \n  p.setup = () => {\n    p.createCanvas(1200,1200);\n    p.background(\"black\")\n\n    tiles.forEach((tile) => {\n      tiles.push(tile.rotate(1))\n      tiles.push(tile.rotate(2))\n      tiles.push(tile.rotate(3))\n    })\n    \n    initGrid(grid, rows, cols)\n    \n    grid[2][0] = Cell([2])\n\n    // document.querySelector(\"canvas\").style.filter = \"invert(1) blur(2px) contrast(.4)\"\n\n    \n  }\n\n  p.draw = () => {\n    // p.tint(\"red\")\n    p.noStroke()\n    draw_grid()\n    step(grid, p)\n  }\n\n  p.mouseClicked = () => {\n    p.redraw()\n  }\n\n  function draw_grid() {\n    let wid = p.width\n    let hei = p.height \n\n    let cell_w = p.width / cols\n    let cell_h = p.height / rows\n\n    for(let y = 0; y < rows; y++ ){\n      for(let x = 0; x < cols; x++ ){\n        let item = grid[y][x]\n        if (item.options.length == 1 && !item.collapsed){\n          // p.rect(x * cell_w, y*cell_h, cell_w, cell_h)\n          p.image(\n            tiles[item.options[0]].image,\n            x * cell_w, y*cell_h, cell_w, cell_h)\n          \n          grid[y][x] = Cell(item.options, true, true)\n        }\n          \n        else if (!item.collapsed && item.options.length > 0) {\n          let total = tiles.length\n          let percent = item.options.length / total * 455\n          let text = item.options.join(\", \")\n          p.fill(percent)\n          p.rect(x * cell_w, y*cell_h, cell_w, cell_h)\n          p.fill(\"yellow\")\n          p.text(text,x * cell_w, y*cell_h, cell_w, cell_h)\n        }\n        \n      }\n    }\n  }\n}\n\n\n\nnew p5(sketch)","blocks":[{"id":"sxxnn","type":"default","code":"","active":true,"focus":false,"focused":false,"output":"// \nlet DIM = 8 \nlet rows = DIM\nlet cols = DIM\n\nlet grid = []\n\nlet raw_tiles = [\n  {\n    src: \"./tiles/0.png\",\n    sockets: [1,0,1,0]\n  },\n  {\n    src: \"./tiles/1.png\",\n    sockets: [1,1,1,0]\n  },\n  \n  {\n    src: \"./tiles/2.png\",\n    sockets: [1,1,0,1]\n  },\n  \n  {\n    src: \"./tiles/3.png\",\n    sockets: [1,0,1,0]\n  },\n  \n  {\n    src: \"./tiles/4.png\",\n    sockets: [1,0,0,1]\n  },\n  \n  {\n    src: \"./tiles/5.png\",\n    sockets: [0,1,1,1]\n  },\n  \n  {\n    src: \"./tiles/6.png\",\n    sockets: [1,0,0,1]\n  },\n  \n  {\n    src: \"./tiles/7.png\",\n    sockets: [0,0,1,1]\n  },\n  \n  {\n    src: \"./tiles/8.png\",\n    sockets: [1,1,1,0]\n  },\n  \n  {\n    src: \"./tiles/9.png\",\n    sockets: [1,0,0,1]\n  },\n  \n  {\n    src: \"./tiles/10.png\",\n    sockets: [0,1,0,1]\n  },\n  \n  {\n    src: \"./tiles/11.png\",\n    sockets: [1,1,0,0]\n  },\n  \n]\n\nlet raw_tiles_2 = [\n  {\n    src: \"./tiles_/0.png\",\n    sockets: [1,0,1,0]\n  },\n  {\n    src: \"./tiles_/1.png\",\n    sockets: [0,0,1,1]\n  },\n  \n  {\n    src: \"./tiles_/2.png\",\n    sockets: [1,1,0,1]\n  },\n  \n  {\n    src: \"./tiles_/3.png\",\n    sockets: [0,1,0,1]\n  },\n  \n  {\n    src: \"./tiles_/4.png\",\n    sockets: [1,1,1,0]\n  },\n  \n  {\n    src: \"./tiles_/5.png\",\n    sockets: [0,1,0,1]\n  },\n  \n  {\n    src: \"./tiles_/6.png\",\n    sockets: [1,0,0,1]\n  },\n  \n  {\n    src: \"./tiles_/7.png\",\n    sockets: [0,0,1,0]\n  },\n  \n  {\n    src: \"./tiles_/8.png\",\n    sockets: [1,1,0,0]\n  },\n  \n]\n\nfunction Cell(options, collapsed = false) {\n  return {\n    options,\n    collapsed\n  }\n}\n\nfunction Tile(imag, sockets, p) {\n  function rotate(num) {\n    // Draw new tile\n    const wi = p.width / rows;\n    const he = p.height / cols;\n    console.log(wi, he)\n    const newImg = p.createGraphics(wi, he);\n\n    newImg.imageMode(p.CENTER)\n    newImg.translate(wi / 2, he / 2);\n    newImg.rotate(newImg.HALF_PI * num);\n    newImg.image(imag, 0, 0, wi, he);\n  \n    // Rotate edges\n    const newSockets = [];\n    const len = sockets.length;\n    for (let i = 0; i < len; i++) {\n      newSockets[i] = sockets[(i - num + len) % len];\n    }\n\n    return Tile(newImg, newSockets, p);\n  }\n  \n  return {\n    image:imag, sockets, rotate\n  }\n}\n\nfunction initGrid(grid, rows, cols, options) {\n  if (!options) options = tiles.map((e, i) => i)\n  for(let y = 0; y < rows; y++ ){\n    grid[y] = []\n    \n    for(let x = 0; x < cols; x++ ){\n      grid[y][x] = Cell(options)\n    }\n  }\n}\n\nfunction neighbour(grid) {\n  const left = (x, y) =>\n    x > 0 \n      ? grid[y][x-1]\n      : null\n  \n  const right = (x, y) =>\n    x < grid[y].length - 1\n      ? grid[y][x + 1]\n      : null\n  \n  const top = (x, y) =>\n    y > 0 \n      ? grid[y-1][x]\n      : null\n  \n  const bottom = (x, y) =>\n    y < grid.length - 1\n      ? grid[y + 1][x]\n      : null\n\n  return {left, right, top, bottom}\n}\n\nfunction step(grid,p) {\n  // will go through the grid\n  // compare neighbours and collect options\n  let n = neighbour(grid)\n  let option_sizes = []\n\n  for(let y = 0; y < rows; y++ ){\n    for(let x = 0; x < cols; x++ ){\n      let item = grid[y][x]\n      let test = new_item(item, x, y, n)\n\n      if(!item.collapsed){\n        let size = test.options.length\n        option_sizes.push(size)\n      }\n      \n      grid[y][x] = test\n    }\n  }\n\n  if (option_sizes.length == 0) {\n    p.noLoop()\n    return\n  }\n\n  let min = option_sizes.reduce(function (p, v) {\n    return ( p < v ? p : v );\n  });\n\n  if (min == 0) min = 1\n\n  // get all cells with least options and randomly select\n  let random = (arr) => {\n    let index = Math.floor(Math.random() * arr.length)\n    return arr[index]\n  }\n\n  let left = []\n  \n  for(let y = 0; y < rows; y++ ){\n    for(let x = 0; x < cols; x++ ){\n      let item = grid[y][x]\n      if (item.options.length == min) {\n        left.push({x, y})\n      }\n    }\n  }\n\n  let c = random(left)\n\n  if(c){\n    let item = grid[c.y][c.x]\n    \n    grid[c.y][c.x].options = [random(item.options)]\n  }\n}\n\n\n\nlet TOP = 0\nlet RIGHT = 1\nlet BOTTOM = 2\nlet LEFT = 3\n\nfunction collapsed_tile(cell) {\n  return tiles[cell.options[0]]\n}\n\nfunction new_item(item, x, y, neighbour){\n  let options = item.options\n  \n  // top\n  let top = neighbour.top(x, y)\n  if (top && top.collapsed) {\n    let top_tile = collapsed_tile(top)\n    \n    options = options.filter((index) => {\n      let me = tiles[index]\n      let a = me.sockets[TOP]\n      let b = top_tile.sockets[BOTTOM]\n      \n      return a == b\n    })\n  }\n  \n  // Bottom\n  let bottom = neighbour.bottom(x, y)\n  if (bottom && bottom.collapsed) {\n    \n    let bottom_tile = collapsed_tile(bottom)\n    \n    options = options.filter((index) => {\n      let me = tiles[index]\n      let a = me.sockets[BOTTOM]\n      let b = bottom_tile.sockets[TOP]\n      \n      return a == b\n    })\n  }\n  \n  // Left\n  let left = neighbour.left(x, y)\n  if (left && left.collapsed) {\n    let left_tile = collapsed_tile(left)\n    \n    options = options.filter((index) => {\n      let me = tiles[index]\n      let a = me.sockets[LEFT]\n      let b = left_tile.sockets[RIGHT]\n      \n      return a == b\n    })\n  }\n  \n  // Right\n  let right = neighbour.right(x, y)\n  if (right && right.collapsed) {\n    let right_tile = collapsed_tile(right)\n    \n    options = options.filter((index) => {\n      let me = tiles[index]\n      let a = me.sockets[RIGHT]\n      let b = right_tile.sockets[LEFT]\n      \n      return a == b\n    })\n  }\n\n  return Cell(options, item.collapsed)\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","cursor":1039},{"id":"in2sf","type":"default","code":"","active":false,"focus":false,"focused":false,"output":"let tiles = []\n\nlet sketch = (p) => {\n  p.preload = () => {\n    \n    raw_tiles_2.forEach((tile) => {\n      let image = p.loadImage(tile.src)\n      let sockets = tile.sockets\n      tiles.push(Tile(image, sockets, p))\n    })\n    raw_tiles.forEach((tile) => {\n      let image = p.loadImage(tile.src)\n      let sockets = tile.sockets\n      tiles.push(Tile(image, sockets, p))\n    })\n    \n  }\n  \n  p.setup = () => {\n    p.createCanvas(1200,1200);\n    p.background(\"black\")\n\n    tiles.forEach((tile) => {\n      tiles.push(tile.rotate(1))\n      tiles.push(tile.rotate(2))\n      tiles.push(tile.rotate(3))\n    })\n    \n    initGrid(grid, rows, cols)\n    \n    grid[2][0] = Cell([2])\n\n    // document.querySelector(\"canvas\").style.filter = \"invert(1) blur(2px) contrast(.4)\"\n\n    \n  }\n\n  p.draw = () => {\n    // p.tint(\"red\")\n    p.noStroke()\n    draw_grid()\n    step(grid, p)\n  }\n\n  p.mouseClicked = () => {\n    p.redraw()\n  }\n\n  function draw_grid() {\n    let wid = p.width\n    let hei = p.height \n\n    let cell_w = p.width / cols\n    let cell_h = p.height / rows\n\n    for(let y = 0; y < rows; y++ ){\n      for(let x = 0; x < cols; x++ ){\n        let item = grid[y][x]\n        if (item.options.length == 1 && !item.collapsed){\n          // p.rect(x * cell_w, y*cell_h, cell_w, cell_h)\n          p.image(\n            tiles[item.options[0]].image,\n            x * cell_w, y*cell_h, cell_w, cell_h)\n          \n          grid[y][x] = Cell(item.options, true, true)\n        }\n          \n        else if (!item.collapsed && item.options.length > 0) {\n          let total = tiles.length\n          let percent = item.options.length / total * 455\n          let text = item.options.join(\", \")\n          p.fill(percent)\n          p.rect(x * cell_w, y*cell_h, cell_w, cell_h)\n          p.fill(\"yellow\")\n          p.text(text,x * cell_w, y*cell_h, cell_w, cell_h)\n        }\n        \n      }\n    }\n  }\n}\n\n\n","cursor":63},{"id":"9qc1vd","type":"default","code":"","active":false,"focus":false,"focused":false,"output":"new p5(sketch)","cursor":0}],"fold":false,"focus":false}]}